# OOPintroHW
OOP Introduction GeekBrains Course Homeworks


# Урок 1. Принципы ООП: Инкапсуляция, наследование, полиморфизм

## Задание

Необходимо создать класс Account, описывающий банковский счет.

Он должен иметь 3 метода: пополнение(`putAmount`) 
и снятие(`takeAmount`) средств и отображение(`getAmount`)
текущего баланса (геттер).

Первые два меняют баланс, последний просто возвращает его.

Далее, необходимо создать наследника - `CreditAccount`, 
описывающий кредитный счет.

Снятие средств с этого кредитного счета 
облагается комиссией в размере 1% от суммы снятия.

Далее, необходимо создать наследника - `DepositAccount`, 
описывающий депозитный счет.

Его особенность в том, что нельзя снимать средства в 
течение 1 месяца после пополнения.

## Решение

Решение находится в папке Task1. Код основной программы в Program.java.

# Урок 2. Принципы ООП Абстракция и интерфейсы. Пример проектирования

## Задание

Представьте, что вы разработчик какой-то компьютерной игры.
Вам поручили реализовать механизм "прокачки" вашего игрового персонажа.
Необходимо разработать класс-хендлер, который срабатывает на разных событиях,
ведущих к повышению уровня опыта.

У каждого обладателя опыта есть 3 параметра:
1. текущий уровень (число)
2. кол-во опыта, необходимое для достижения нового уровня
3. кол-во опыта, добытого на текущем уровне

Какие нужны классы и интерфейсы для реализации данной фичи?

1. Интерфейс, описывающий наличие очков опыта и возможности прокачки. У него должны быть методы:
    * int getCurrentLevel() - текущий уровень
    * int getCurrentExperience() - кол-во опыта на текущем уровне
    * int getLevelExperience() - кол-во опыта, необходимое для достижения следующего уровня
    * void setCurrentLevel(int level) - обновляет текущий уровень
    * void setCurrentExperience(int exp) - обновляет текущее количество очков опыта на текущем уровне
2. Интерфейс, отражающий событие, которое приводит к увеличению опыта У него должны быть метод:
    * int getExperience() - кол-во очков опыта для зачисления, которое дает данное событие
3. Класс-обработчик, который принимает интерфейсы из пунктов 1 и 2, и обновляет объекту интерфейса 1 очки опыта (и, возможно, поднимает текущий уровень).
   PS Для полного понимания контекста рекомендуется посмотреть запись семинара от 11 декабря 2023.

## Решение

Решение находится в папке Task2. Код основной программы в Task2.Program.java.

# Урок 3. Некоторые стандартные интерфейсы Java и примеры их использования

## Задача

Создать класс Employee (сотрудник) со следующими полями:
1. String name - имя
2. int age - возраст
3. double salary - зарплата

Необходимо: 
1. Создать список из 10-20 рандомных сотрудников.
2. Отсортировать его по убыванию возрастов (от большего к меньшему).
3. Отсортировать его по возрастанию зарплаты.
4. Вывести топ-5 сотрудников с наибольшей зарплатой, отсортированных по имени в алфавитном порядке.
5. Отсортировать сотрудников по возрастанию возрастов.
   * Если возрасты одинаковые - то по убыванию зарплаты.
   * Если и они равны - в алфавитном порядке.

## Решение

Решение находится в папке Task3. Код основной программы в Task3.Program.java.

# Урок 4. ООП: Обобщения. ч1

## Задача

Необходимо описать класс Box, который должен хранить фрукты одного типа.

У этого класса должны быть методы:
1. Добавить фрукт какого-то типа
2. Узнать суммарный вес всех фруктов в коробке
3. Пересыпать все фрукты в другую коробку
4. Реализовать возможность перечисления по коробке

```
public class Homework {
   public static void main(String[] args) {
   Box<String> strings = new Box<>(); // не должно компилироваться
      
      Box<Orange> oranges = new Box<>();
      oranges.add(new Orange(1));
      System.out.println(oranges.getWeight()); // 1
      oranges.add(new Orange(2));
      System.out.println(oranges.getWeight()); // 3
      
      Box<Apple> apples = new Box<>();
      apples.add(new Orange(3)); // не должно компилироваться!
      apples.add(new GoldenApple(5)); // это ок
      
      Box<GoldenApple> goldenApples = new Box<>();
      goldenApples.add(new GoldenApple(5)); // это ок
      goldenApples.add(new Apple(3)); // не должно компилироваться!
      
      oranges.move(apples); // не должно компилироваться!
      goldenApples.move(apples); // это ок
      apples.move(goldenApples); // не должно компилироваться!
      
      Box<Orange> newOranges = new Box<>();
      oranges.move(newOranges);
      System.out.println(oranges.getWeight()); // 0 после пересыпания
      System.out.println(newOranges.getWeight()); // 3 после пересыпания
      
      for (Orange o: oranges) { // цикл компилируется, но не запускатся, потому oranges - пустой
      System.out.println(o.getWeight());
      }
      
      for (Orange o: newOranges) { // цикл компилируется, и запускается
      // Должно вывести 1 2 (или 2 1) - порядок неважен
      System.out.println(o.getWeight());
      }
      
      for (Apple a: apples) { // цикл компилируется, и запускается
      // Должно вывести 5 5
      System.out.println(a.getWeight());
      }
   }

   static class Box {
      // Реализовать данный класс!!!
   }
   
   static class Fruit {
      private final int weight;
      
      public Fruit(int weight) {
         this.weight = weight;
      }
      
      public int getWeight() {
         return weight;
      }
   }
   
   static class Orange extends Fruit {
      public Orange(int weight) {
         super(weight);
      }
   }
   
   static class Apple extends Fruit {
      public Apple(int weight) {
         super(weight);
      }
   }
   
   static class GoldenApple extends Apple {
      public GoldenApple(int weight) {
         super(weight);
      }
   }
}
```

## Решение

Решение находится в папке Task4. Код основной программы в Task4.Program.java.